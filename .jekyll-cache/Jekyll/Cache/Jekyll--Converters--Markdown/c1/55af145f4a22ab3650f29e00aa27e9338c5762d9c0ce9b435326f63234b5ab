I"G*<p>친구가 재밌다고 추천해준 책, 그래 그래 효율성..</p>

<p>링크 : http://book.naver.com/bookdb/book_detail.nhn?bid=7405945</p>

<p>저자 마틴 레디 (DR. MARTIN REDDY)는 소프트웨어 컨설팅 회사인 CODE REDDY INC.의 설립자이자 CEO다.</p>

<p><img src="/assets/images/posts/437/2638BF4F56777D61139560.JPEG" alt="" /></p>

<p>chpater 1 소개</p>

<p>1.1애플리케이션 프로그래밍 인터페이스</p>

<p>1.1.1계약과 계약자</p>

<p>1.1.2C++로 구현하는 API</p>

<p>1.2API 설계의 차별화되는 특징</p>

<p>1.3API를 사용하는 이유</p>

<p>1.3.1좀 더 견고한 코드</p>

<p>1.3.2코드 재사용</p>

<p>1.3.3병렬 개발</p>

<p>1.4API를 사용하지 말아야 할 때</p>

<p>1.5예제 API</p>

<p>1.5.1API 계층</p>

<p>1.5.2실세계 예제</p>

<p>1.6파일 포맷과 네트워크 프로토콜</p>

<p>1.7이 책의 구성</p>

<p>chpater 2품질</p>

<p>2.1문제 도메인 모델</p>

<p>2.1.1훌륭한 추상화 제공</p>

<p>2.1.2핵심 객체 모델링</p>

<p>2.2구체적인 구현 숨기기</p>

<p>2.2.1물리적 은닉: 선언 vs 정의</p>

<p>2.2.2논리적 은닉: 캡슐화</p>

<p>2.2.3멤버 변수 감추기</p>

<p>2.2.4메서드 구현 숨기기</p>

<p>2.2.5클래스 구현 숨기기</p>

<p>2.3작게 완성하기</p>

<p>2.3.1지나친 약속은 금지</p>

<p>2.3.2가상 함수의 추가는 신중하게</p>

<p>2.3.3편리한 API</p>

<p>2.4쉬운 사용성</p>

<p>2.4.1한눈에 들어오는</p>

<p>2.4.2잘못 사용하기에도 어렵게</p>

<p>2.4.3일관성 있는</p>

<p>2.4.4수직적인</p>

<p>2.4.5견고한 자원 할당</p>

<p>2.4.6플랫폼 독립성</p>

<p>2.5느슨한 연결</p>

<p>2.5.1이름만을 사용한 연결</p>

<p>2.5.2클래스 연결 줄이기</p>

<p>2.5.3의도적인 중복</p>

<p>2.5.4매니저 클래스</p>

<p>2.5.5콜백과 옵저버, 알림</p>

<p>2.6안정화와 문서화, 테스트</p>

<p>chpater 3 패턴</p>

<p>3.1Pimpl 관용법</p>

<p>3.1.1Pimpl 사용</p>

<p>3.1.2의미론적 복사</p>

<p>3.1.3Pimpl과 스마트 포인터</p>

<p>3.1.4Pimpl의 장점</p>

<p>3.1.5Pimpl의 단점</p>

<p>3.1.6C의 Opaque 포인터</p>

<p>3.2싱글톤</p>

<p>3.2.1C++의 싱글톤 구현</p>

<p>3.2.2스레드에 안전한 싱글톤 만들기</p>

<p>3.2.3싱글톤 vs 의존성 삽입</p>

<p>3.2.4싱글톤 vs 모노스테이트</p>

<p>3.2.5싱글톤 vs 세션 상태</p>

<p>3.3팩토리 메서드</p>

<p>3.3.1추상 기본 클래스</p>

<p>3.3.2단순한 팩토리 예제</p>

<p>3.3.3확장 가능한 팩토리 예제</p>

<p>3. 4API 래핑 패턴</p>

<p>3.4.1프록시 패턴</p>

<p>3.4.2어댑터 패턴</p>

<p>3.4.3퍼사드 패턴</p>

<p>3.5옵저버 패턴</p>

<p>3.5.1모델-뷰-컨트롤러</p>

<p>3.5.2옵저버 패턴 구현</p>

<p>3.5.3푸시 옵저버 VS 풀 옵저버</p>

<p>chpater 4 설계</p>

<p>4.1좋은 설계를 위한 사례</p>

<p>4.1.1기술적 부채의 증가</p>

<p>4.1.2부채 상환</p>

<p>4.1.3멀리 보는 설계</p>

<p>4.2기능적 요구사항 수집</p>

<p>4.2.1기능적 요구사항</p>

<p>4.2.2기능적 요구사항의 예</p>

<p>4.2.3요구사항 유지보수</p>

<p>4.3유즈 케이스 생성</p>

<p>4.3.1유즈 케이스 개발</p>

<p>4.3.2유즈 케이스 템플릿 사용</p>

<p>4.3.3좋은 유즈 케이스 작성</p>

<p>4.3.4요구사항과 애자일 개발</p>

<p>4.4API 설계 요소</p>

<p>4.5아키텍처 설계</p>

<p>4.5.1아키텍처 수립</p>

<p>4.5.2아키텍처의 제약사항</p>

<p>4.5.3주요 추상화 객체 식별</p>

<p>4.5.4핵심 객체 생성</p>

<p>4.5.5아키텍처 관점 패턴</p>

<p>4.5.6아키텍처 논의</p>

<p>4.6클래스 설계</p>

<p>4.6.1객체 지향 개념</p>

<p>4.6.2클래스 설계의 선택사항</p>

<p>4.6.3상속 사용</p>

<p>4.6.4리스코브 대리 원칙</p>

<p>4.6.5개방/폐쇄 원칙</p>

<p>4.6.6데메테르의 법</p>

<p>4.6.7클래스 이름</p>

<p>4.7함수 설계</p>

<p>4.7.1함수 설계의 선택사항</p>

<p>4.7.2함수 이름</p>

<p>4.7.3함수 파라미터</p>

<p>4.7.4예외 처리</p>

<p>chpater 5 API 개발 방법</p>

<p>5.1일반 C API</p>

<p>5.1.1ANSI C 기능</p>

<p>5.1.2ANSI C API의 장점</p>

<p>5.1.3ANSI C로 API 작성</p>

<p>5.1.4C++ 코드에서 C 함수 호출</p>

<p>5.1.5사례 연구: FMOD C API</p>

<p>5.2객체 지향 C++ API</p>

<p>5.2.1객체 지향 API의 장점</p>

<p>5.2.2객체 지향 API의 단점</p>

<p>5.2.3사례 연구: FMOD C++ API</p>

<p>5.3템플릿 기반 API</p>

<p>5.3.1템플릿 기반 API 예제245</p>

<p>5.3.2템플릿 vs 매크로</p>

<p>5.3.3템플릿 기반 API의 장점</p>

<p>5.3.4템플릿 기반 API의 단점</p>

<p>5.4데이터 주도 API</p>

<p>5.4.1데이터 주도 웹 서비스</p>

<p>5.4.2데이터 주도 API의 장점</p>

<p>5.4.3데이터 주도 API의 단점</p>

<p>5.4.4가변형 파라미터 리스트 지원</p>

<p>5.4.5사례 연구: FMOD 데이터 주도 API</p>

<p>chpater 6C++의 올바른 사용법</p>

<p>6.1네임스페이스</p>

<p>6.2생성자와 할당</p>

<p>6.2.1컴파일러 생성 함수 제어</p>

<p>6.2.2생성자와 할당 정의</p>

<p>6.2.3Explicit 키워드</p>

<p>6.3상수 정확성</p>

<p>6.3.1메서드 상수 정확성</p>

<p>6.3.2파라미터 상수 정확성</p>

<p>6.3.3리턴 값 상수 정확성</p>

<p>6.4템플릿</p>

<p>6.4.1템플릿 용어</p>

<p>6.4.2암시적 인스턴스화 API 설계</p>

<p>6.4.3명시적 인스턴스화 API 설계</p>

<p>6.5연산자 오버로딩</p>

<p>6.5.1오버로드 가능한 연산자</p>

<p>6.5.2자유 연산자와 멤버 연산자</p>

<p>6.5.3클래스에 새 연산자 추가</p>

<p>6.5.4연산자 문법</p>

<p>6.5.5형 변환 연산자</p>

<p>6.6함수 파라미터</p>

<p>6.6.1포인터 피라미터 vs 참조 파라미터</p>

<p>6.6.2기본 파라미터</p>

<p>6.7상수에 #DEFINE 사용 금지</p>

<p>6.8프렌드 사용 금지</p>

<p>6.9심벌 노출</p>

<p>6.10코딩 규칙</p>

<p>chpater 7 성능</p>

<p>7.1상수 참조로 입력 파라미터 전달</p>

<p>7.2#INCLUDE 의존성 최소화</p>

<p>7.2.1 “한곳에 몰아두는” 헤더 금지</p>

<p>7.2.2전방 선언</p>

<p>7.2.3#include 중복 방지</p>

<p>7.3상수 선언</p>

<p>7.3.1새로운 constexpr 키워드3</p>

<p>7.4초기화 리스트</p>

<p>7.5메모리 최적화</p>

<p>7.6필요시까지 인라인 사용 금지</p>

<p>7.7카피-온-라이트</p>

<p>7.8요소 반복</p>

<p>7.8.1반복자</p>

<p>7.8.2임의 접근</p>

<p>7.8.3배열 참조</p>

<p>7.9성능 분석</p>

<p>7.9.1시간 기반 분석</p>

<p>7.9.2메모리 기반 분석</p>

<p>7.9.3멀티스레드 분석</p>

<p>chpater 8버전 관리</p>

<p>8.1버전 번호</p>

<p>8.1.1버전 번호의 의미</p>

<p>8.1.2일부만 아는 버전 규칙</p>

<p>8.1.3버전 API 생성</p>

<p>8.2소프트웨어 브랜치 전략</p>

<p>8.2.1브랜치 전략</p>

<p>8.2.2브랜치 정책</p>

<p>8.2.3API와 병렬 브랜치</p>

<p>8.2.4파일 포맷과 병렬 제품</p>

<p>8.3API의 수명 주기</p>

<p>8.4호환성 수준</p>

<p>8.4.1하위 호환성</p>

<p>8.4.2기능적 호환성</p>

<p>8.4.3소스 호환성</p>

<p>8.4.4이진 호환성</p>

<p>8.4.5상위 호환성</p>

<p>8.5하위 호환성 유지</p>

<p>8.5.1기능 추가</p>

<p>8.5.2기능 변경</p>

<p>8.5.3기능 교체</p>

<p>8.5.4기능 제거</p>

<p>8.6API 리뷰</p>

<p>8.6.1API 리뷰의 목적</p>

<p>8.6.2사전 릴리즈 리뷰</p>

<p>8.6.3사전 커밋 API 리뷰</p>

<p>chpater 9 문서화</p>

<p>9.1문서화의 이유</p>

<p>9.1.1행동 정의</p>

<p>9.1.2인터페이스 계약 문서화</p>

<p>9.1.3행동 변화에 대한 의사소통</p>

<p>9.1.4문서화의 대상</p>

<p>9.2문서화의 유형</p>

<p>9.2.1자동화된 API 문서화</p>

<p>9.2.2개요 문서화</p>

<p>9.2.3예제와 튜토리얼</p>

<p>9.2.4릴리즈 노트</p>

<p>9.2.5라이선스 정보</p>

<p>9.3문서 활용</p>

<p>9.4DOXYGEN 사용</p>

<p>9.4.1구성 파일</p>

<p>9.4.2주석 스타일과 명령</p>

<p>9.4.3API 주석</p>

<p>9.4.4파일 주석</p>

<p>9.4.5클래스 주석</p>

<p>9.4.6메서드 주석</p>

<p>9.4.7열거형 주석</p>

<p>9.4.8예제 헤더 문서화</p>

<p>chpater 10 테스트</p>

<p>10.1테스트 코드가 필요한 이유</p>

<p>10.2API 테스트의 유형</p>

<p>10.2.1단위 테스트</p>

<p>10.2.2통합 테스트</p>

<p>10.2.3성능 테스트</p>

<p>10.3좋은 테스트 코드 작성</p>

<p>10.3.1좋은 테스트 코드의 특성</p>

<p>10.3.2테스트의 대상</p>

<p>10.3.3테스트의 선택과 집중</p>

<p>10.3.4QA 팀의 협업</p>

<p>10.4테스트 가능한 코드의 작성</p>

<p>10.4.1테스트 주도 개발</p>

<p>10.4.2스텁(Stub)과 목(Mock) 객체</p>

<p>10.4.3Private 코드 테스트</p>

<p>10.4.4테스트 결과 표명</p>

<p>10.4.5계약 프로그래밍</p>

<p>10.4.6기록과 재생 기능</p>

<p>10.4.7국제화 지원</p>

<p>10.5테스트 자동화 도구</p>

<p>10.5.1테스트 하네스</p>

<p>10.5.2코드 커버리지</p>

<p>10.5.3버그 추적</p>

<p>10.5.4지속적인 빌드 시스템</p>

<p>chpater 11 스크립팅</p>

<p>11.1스크립트 바인딩 추가</p>

<p>11.1.1확장 vs 임베딩</p>

<p>11.1.2스크립팅의 장점</p>

<p>11.1.3언어 호환성 문제</p>

<p>11.1.4언어 장벽 교차</p>

<p>11.2스크립트 바인딩 기법</p>

<p>11.2.1Boost Python</p>

<p>11.2.2SWIG</p>

<p>11.2.3Python-SIP</p>

<p>11.2.4COM 자동화</p>

<p>11.2.5CORBA</p>

<p>11.3BOOST PYTHON을 사용한 PYTHON 바인딩 추가</p>

<p>11.3.1Boost Python 바인딩</p>

<p>11.3.2Boost Python을 사용한 C++ API 래핑</p>

<p>11.3.3생성자</p>

<p>11.3.4Python API 확장</p>

<p>11.3.5C++의 상속</p>

<p>11.3.6교차 언어 다형성</p>

<p>11.3.7반복자 지원</p>

<p>11.3.8종합</p>

<p>11.4SWIG를 이용한 RUBY 바인딩 추가</p>

<p>11.4.1SWIG를 사용한 C++ API 래핑</p>

<p>11.4.2Ruby API 개선</p>

<p>11.4.3생성자</p>

<p>11.4.4Ruby API 확장</p>

<p>11.4.5C++의 상속</p>

<p>11.4.6교차 언어 다형성</p>

<p>11.4.7종합</p>

<p>chpater 12확장성</p>

<p>12.1플러그인을 통한 확장</p>

<p>12.1.1플러그인 모델의 개요</p>

<p>12.1.2플러그인 시스템 설계 이슈</p>

<p>12.1.3C++로 플러그인 개발</p>

<p>12.1.4플러그인 API</p>

<p>12.1.5예제 플러그인</p>

<p>12.1.6플러그인 매니저</p>

<p>12.1.7플러그인 버전 관리</p>

<p>12.2상속을 통한 확장</p>

<p>12.2.1기능 추가</p>

<p>12.2.2기능 수정</p>

<p>12.2.3상속과 STL</p>

<p>12.2.4상속과 열거형</p>

<p>12.2.5비지터 패턴</p>

<p>12.2.6서브 클래스 사용 금지</p>

<p>12.3템플릿을 통한 확장</p>

<p>12.3.1정책 기반 템플릿</p>

<p>12.3.2정교하게 반복되는 템플릿 패턴</p>

:ET