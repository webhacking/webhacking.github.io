I":<p>요즘 <code class="highlighter-rouge">클린 코드</code>에 관심이 많다.</p>

<p>코드또한 하나의 글이다.</p>

<p>잘 쓰여진 코드는 아름다운 문장과 같고, 버그를 심을 확률이 낮아진다.</p>

<p>깔끔한 코드를 원한다면, 바로 코드를 작성하기 앞 서 생각을 하길 바란다.</p>

<p>이 후, 자신의 생각 또한 깔끔히 정리가 되었다면 그 때 코드를 작성하면 좋다.</p>

<blockquote>
  <p>깔끔하게 글을 쓰고 싶다면, 먼저 생각을 깔끔하게 정리하라.</p>
</blockquote>

<blockquote>

</blockquote>

<blockquote>
  <p>-요한 폰 괴테</p>
</blockquote>

<p>코드를 대체해 주석으로 의도를 가리키는 개발자들도 많이봤다.</p>

<p>항상 주석이 중요하다고 배웠다. 그런데 왜 ? 코드가 명확하다면 코드자체로 의도를 가리킬수있는 것 아닌가?</p>

<p>깔끔한 코드는 단순 문법만을 나타내는 것은 절대 아니다. 해당 책에는 정말 좋은 내용들이 많이 담겨있다.</p>

<p>그 내용들만 잘 살려 나 자신에게 반영한다면 더 좋은 개발자로 거듭나는데 한 발자국 내딛는 것 아닌가.. !</p>

<blockquote>

  <p>장인 정신을 익히는 과정은 두 단계로 나뉜다. 바로 이론과 실전이다. 첫째, 장인에게 필요한 원칙, 패턴, 기법, 경험이라는 지식을 습득해야
한다. 둘째, 열심히 일하고 연습해 지식을 몸과 마음으로 체득해야 한다.</p>
</blockquote>

<blockquote>

</blockquote>

<blockquote>

</blockquote>

<blockquote>
  <p>함수는 추상화 수준을 한 단계만 내려가야 한다. 함수 내 모든 문장은 추상화 수준이 동일해야 한다 그리고 그 추상화 수준은 함수 이름이
의미하는 작업보다 한 단계 만 낮아야 한다.</p>
</blockquote>

<p>한짤 요약하면 아래와 같다.</p>

<p>전자가 되도록 노력하자 ..!</p>

<p><img src="/assets/images/posts/693/27354E3857E9CBF109B0A8.JPEG" alt="" /></p>

<p><strong>1장 깨끗한 코드</strong></p>

<p>코드가 존재하리라</p>

<p>나쁜 코드<br />
나쁜 코드로 치르는 대가<br />
__ 원대한 재설계의 꿈<br />
__ 태도<br />
__ 원초적 난제<br />
__ 깨끗한 코드라는 예술?<br />
__ 깨끗한 코드란?<br />
우리들 생각<br />
우리는 저자다<br />
보이스카우트 규칙<br />
프리퀄과 원칙<br />
결론</p>

<p>참고 문헌</p>

<p><strong>2장 의미 있는 이름</strong><br />
들어가면서<br />
의도를 분명히 밝혀라<br />
그릇된 정보를 피하라<br />
의미 있게 구분하라<br />
발음하기 쉬운 이름을 사용하라<br />
검색하기 쉬운 이름을 사용하라<br />
인코딩을 피하라<br />
__ 헝가리식 표기법<br />
__ 멤버 변수 접두어<br />
__ 인터페이스 클래스와 구현 클래스<br />
자신의 기억력을 자랑하지 마라<br />
클래스 이름<br />
메서드 이름<br />
기발한 이름은 피하라<br />
한 개념에 한 단어를 사용하라<br />
말장난을 하지 마라<br />
해법 영역에서 가져온 이름을 사용하라<br />
문제 영역에서 가져온 이름을 사용하라<br />
의미 있는 맥락을 추가하라<br />
불필요한 맥락을 없애라<br />
마치면서</p>

<p><strong>3장 함수</strong><br />
작게 만들어라!<br />
__ 블록과 들여쓰기<br />
한 가지만 해라!<br />
__ 함수 내 섹션<br />
함수 당 추상화 수준은 하나로!<br />
__ 위에서 아래로 코드 읽기: 내려가기 규칙<br />
SWITCH 문<br />
서술적인 이름을 사용하라!<br />
함수 인수<br />
__ 많이 쓰는 단항 형식<br />
__ 플래그 인수<br />
__ 이항 함수<br />
__ 삼항 함수<br />
__ 인수 객체<br />
__ 인수 목록<br />
__ 동사와 키워드<br />
부수 효과를 일으키지 마라!<br />
__ 출력 인수<br />
명령과 조회를 분리하라!<br />
오류 코드보다 예외를 사용하라!<br />
__ TRY/CATCH 블록 뽑아내기<br />
__ 오류 처리도 한 가지 작업이다.<br />
__ ERROR.JAVA 의존성 자석<br />
반복하지 마라!<br />
구조적 프로그래밍<br />
함수를 어떻게 짜죠?<br />
결론<br />
참고 문헌</p>

<p>**4장 주석<br />
**주석은 나쁜 코드를 보완하지 못한다<br />
코드로 의도를 표현하라!<br />
좋은 주석<br />
__ 법적인 주석<br />
__ 정보를 제공하는 주석<br />
__ 의도를 설명하는 주석<br />
__ 의미를 명료하게 밝히는 주석<br />
__ 결과를 경고하는 주석<br />
__ TODO 주석<br />
__ 중요성을 강조하는 주석<br />
__ 공개 API에서 JAVADOCS<br />
나쁜 주석<br />
__ 주절거리는 주석<br />
__ 같은 이야기를 중복하는 주석<br />
__ 오해할 여지가 있는 주석<br />
__ 의무적으로 다는 주석<br />
__ 이력을 기록하는 주석<br />
__ 있으나 마나 한 주석<br />
__ 무서운 잡음<br />
__ 함수나 변수로 표현할 수 있다면 주석을 달지 마라<br />
__ 위치를 표시하는 주석<br />
__ 닫는 괄호에 다는 주석<br />
__ 공로를 돌리거나 저자를 표시하는 주석<br />
__ 주석으로 처리한 코드<br />
__ HTML 주석<br />
__ 전역 정보<br />
__ 너무 많은 정보<br />
__ 모호한 관계<br />
__ 함수 헤더<br />
__ 비공개 코드에서 JAVADOCS<br />
__ 예제<br />
참고 문헌</p>

<p><strong>5장 형식 맞추기</strong><br />
형식을 맞추는 목적<br />
적절한 행 길이를 유지하라<br />
__ 신문 기사처럼 작성하라<br />
__ 개념은 빈 행으로 분리하라<br />
__ 세로 밀집도<br />
__ 수직 거리<br />
__ 세로 순서<br />
가로 형식 맞추기<br />
__ 가로 공백과 밀집도<br />
__ 가로 정렬<br />
__ 들여쓰기<br />
가짜 범위<br />
팀 규칙<br />
밥 아저씨의 형식 규칙</p>

<p><strong>6장 객체와 자료 구조</strong><br />
자료 추상화<br />
자료/객체 비대칭<br />
디미터 법칙<br />
__ 기차 충돌<br />
__ 잡종 구조<br />
__ 구조체 감추기<br />
자료 전달 객체<br />
__ 활성 레코드<br />
결론<br />
참고 문헌</p>

<p><strong>7장 오류 처리</strong><br />
오류 코드보다 예외를 사용하라<br />
TRY-CATCH-FINALLY 문부터 작성하라<br />
미확인UNCHECKED 예외를 사용하라<br />
예외에 의미를 제공하라<br />
호출자를 고려해 예외 클래스를 정의하라<br />
정상 흐름을 정의하라<br />
NULL을 반환하지 마라<br />
NULL을 전달하지 마라<br />
결론<br />
참고문헌</p>

<p><strong>8장 경계</strong><br />
외부 코드 사용하기<br />
경계 살피고 익히기<br />
LOG4J 익히기<br />
학습 테스트는 공짜 이상이다<br />
아직 존재하지 않는 코드를 사용하기<br />
깨끗한 경계<br />
참고 문헌</p>

<p>**<br />
**</p>

<p><strong>9장 단위 테스트</strong><br />
TDD 법칙 세 가지<br />
깨끗한 테스트 코드 유지하기<br />
__ 테스트는 유연성, 유지보수성, 재사용성을 제공한다<br />
깨끗한 테스트 코드<br />
__ 도메인에 특화된 테스트 언어<br />
__ 이중 표준<br />
테스트 당 ASSERT 하나<br />
__ 테스트 당 개념 하나<br />
F.I.R.S.T.<br />
결론<br />
참고 문헌</p>

<p><strong>10장 클래스</strong><br />
클래스 체계<br />
__ 캡슐화<br />
클래스는 작아야 한다!<br />
__ 단일 책임 원칙<br />
__ 응집도COHESION<br />
__ 응집도를 유지하면 작은 클래스 여럿이 나온다<br />
변경하기 쉬운 클래스<br />
__ 변경으로부터 격리<br />
참고 문헌</p>

<p><strong>11장 시스템</strong><br />
도시를 세운다면?<br />
시스템 제작과 시스템 사용을 분리하라<br />
__ MAIN 분리<br />
__ 팩토리<br />
__ 의존성 주입<br />
확장<br />
__ 횡단(CROSS-CUTTING) 관심사<br />
자바 프록시<br />
순수 자바 AOP 프레임워크<br />
ASPECTJ 관점<br />
테스트 주도 시스템 아키텍처 구축<br />
의사 결정을 최적화하라<br />
명백한 가치가 있을 때 표준을 현명하게 사용하라<br />
시스템은 도메인 특화 언어가 필요하다<br />
결론<br />
참고 문헌</p>

<p><strong>12장 창발성(創發性)</strong><br />
창발적 설계로 깔끔한 코드를 구현하자<br />
단순한 설계 규칙 1: 모든 테스트를 실행하라<br />
단순한 설계 규칙 2~4: 리팩터링<br />
중복을 없애라<br />
표현하라<br />
클래스와 메서드 수를 최소로 줄여라<br />
결론<br />
참고 문헌</p>

<p><strong>13장 동시성</strong><br />
동시성이 필요한 이유?<br />
__ 미신과 오해<br />
난관<br />
동시성 방어 원칙<br />
__ 단일 책임 원칙SINGLE RESPONSIBILITY PRINCIPLE, SRP<br />
__ 따름 정리COROLLARY: 자료 범위를 제한하라<br />
__ 따름 정리: 자료 사본을 사용하라<br />
__ 따름 정리: 스레드는 가능한 독립적으로 구현하라<br />
라이브러리를 이해하라<br />
__ 스레드 환경에 안전한 컬렉션<br />
실행 모델을 이해하라<br />
__ 생산자-소비자PRODUCER-CONSUMER<br />
__ 읽기-쓰기READERS-WRITERS<br />
__ 식사하는 철학자들DINING PHILOSOPHERS<br />
동기화하는 메서드 사이에 존재하는 의존성을 이해하라<br />
동기화하는 부분을 작게 만들어라<br />
올바른 종료 코드는 구현하기 어렵다<br />
스레드 코드 테스트하기<br />
__ 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라<br />
__ 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자<br />
__ 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를<br />
구현하라<br />
__ 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라<br />
__ 프로세서 수보다 많은 스레드를 돌려보라<br />
__ 다른 플랫폼에서 돌려보라<br />
__ 코드에 보조 코드INSTRUMENT를 넣어 돌려라. 강제로 실패를 일으키게 해보라<br />
__ 직접 구현하기<br />
__ 자동화<br />
결론<br />
참고 문헌</p>

<p><strong>14장 점진적인 개선</strong><br />
ARGS 구현<br />
__ 어떻게 짰느냐고?<br />
ARGS: 1차 초안<br />
__ 그래서 멈췄다<br />
__ 점진적으로 개선하다<br />
STRING 인수<br />
결론</p>

<p><strong>15장 JUNIT 들여다보기</strong><br />
JUNIT 프레임워크<br />
결론</p>

<p>**16장 SERIALDATE 리팩터링<br />
**첫째, 돌려보자<br />
둘째, 고쳐보자<br />
결론<br />
참고 문헌</p>

<p>**17장 냄새와 휴리스틱<br />
**주석<br />
__ C1: 부적절한 정보<br />
__ C2: 쓸모 없는 주석<br />
__ C3: 중복된 주석<br />
__ C4: 성의 없는 주석<br />
__ C5: 주석 처리된 코드<br />
환경<br />
__ E1: 여러 단계로 빌드해야 한다<br />
__ E2: 여러 단계로 테스트해야 한다<br />
함수<br />
__ F1: 너무 많은 인수<br />
__ F2: 출력 인수<br />
__ F3: 플래그 인수<br />
__ F4: 죽은 함수<br />
일반<br />
__ G1: 한 소스 파일에 여러 언어를 사용한다<br />
__ G2: 당연한 동작을 구현하지 않는다<br />
__ G3: 경계를 올바로 처리하지 않는다<br />
__ G4: 안전 절차 무시<br />
__ G5: 중복<br />
__ G6: 추상화 수준이 올바르지 못하다<br />
__ G7: 기초 클래스가 파생 클래스에 의존한다<br />
__ G8: 과도한 정보<br />
__ G9: 죽은 코드<br />
__ G10: 수직 분리<br />
__ G11: 일관성 부족<br />
__ G12: 잡동사니<br />
__ G13: 인위적 결합<br />
__ G14: 기능 욕심<br />
__ G15: 선택자 인수<br />
__ G16: 모호한 의도<br />
__ G17: 잘못 지운 책임<br />
__ G18: 부적절한 STATIC 함수<br />
__ G19: 서술적 변수<br />
__ G20: 이름과 기능이 일치하는 함수<br />
__ G21: 알고리즘을 이해하라<br />
__ G22: 논리적 의존성은 물리적으로 드러내라<br />
__ G23: IF/ELSE 혹은 SWITCH/CASE 문보다 다형성을 사용하라<br />
__ G24: 표준 표기법을 따르라<br />
__ G25: 매직 숫자는 명명된 상수로 교체하라<br />
__ G26: 정확하라<br />
__ G27: 관례보다 구조를 사용하라<br />
__ G28: 조건을 캡슐화하라<br />
__ G29: 부정 조건은 피하라<br />
__ G30: 함수는 한 가지만 해야 한다<br />
__ G31: 숨겨진 시간적인 결합<br />
__ G32: 일관성을 유지하라<br />
__ G33: 경계 조건을 캡슐화하라<br />
__ G34: 함수는 추상화 수준을 한 단계만 내려가야 한다<br />
__ G35: 설정 정보는 최상위 단계에 둬라<br />
__ G36: 추이적 탐색을 피하라<br />
자바<br />
__ J1: 긴 IMPORT 목록을 피하고 와일드카드를 사용하라<br />
__ J2: 상수는 상속하지 않는다<br />
__ J3: 상수 대 ENUM<br />
이름<br />
__ N1: 서술적인 이름을 사용하라<br />
__ N2: 적절한 추상화 수준에서 이름을 선택하라<br />
__ N3: 가능하다면 표준 명명법을 사용하<br />
__ N4: 명확한 이름<br />
__ N5: 긴 범위는 긴 이름을 사용하라<br />
__ N6: 인코딩을 피하라<br />
__ N7: 이름으로 부수 효과를 설명하라<br />
테스트<br />
__ T1: 불충분한 테스트<br />
__ T2: 커버리지 도구를 사용하라!<br />
__ T3: 사소한 테스트를 건너뛰지 마라<br />
__ T4: 무시한 테스트는 모호함을 뜻한다<br />
__ T5: 경계 조건을 테스트하라<br />
__ T6: 버그 주변은 철저히 테스트하라<br />
__ T7: 실패 패턴을 살펴라<br />
__ T8: 테스트 커버리지 패턴을 살펴라<br />
__ T9: 테스트는 빨라야 한다<br />
결론<br />
참고 문헌<br />
부록A 동시성 II<br />
클라이언트/서버 예제<br />
__ 서버<br />
__ 스레드 추가하기<br />
__ 서버 살펴보기<br />
__ 결론<br />
가능한 실행 경로<br />
__ 경로 수<br />
__ 가능한 순열 수 계산하기<br />
__ 심층 분석<br />
__ 결론<br />
라이브러리를 이해하라<br />
__ EXECUTOR 프레임워크<br />
__ 스레드를 차단하지 않는NON BLOCKING 방법<br />
__ 다중 스레드 환경에서 안전하지 않은 클래스<br />
메서드 사이에 존재하는 의존성을 조심하라<br />
__ 실패를 용인한다<br />
__ 클라이언트-기반 잠금<br />
__ 서버-기반 잠금<br />
작업 처리량 높이기<br />
__ 작업 처리량 계산 - 단일스레드 환경<br />
__ 작업 처리량 계산 - 다중 스레드 환경<br />
데드락<br />
__ 상호 배제MUTUAL EXCLUSION<br />
__ 잠금 &amp; 대기LOCK &amp; WAIT<br />
__ 선점 불가NO PREEMPTION<br />
__ 순환 대기CIRCULAR WAIT<br />
__ 상호 배제 조건 깨기<br />
__ 잠금 &amp; 대기 조건 깨기<br />
__ 선점 불가 조건 깨기<br />
__ 순환 대기 조건 깨기<br />
__ 다중 스레드 코드 테스트<br />
__ 스레드 코드 테스트를 도와주는 도구</p>

:ET