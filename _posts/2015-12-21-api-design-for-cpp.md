---
layout: post
title: "C++ API 디자인(API Design for C++)"
description: ""
categories : etc
sub_categories : ""
date: 2015-12-21
tags: []
comments: true
share: true
---

친구가 재밌다고 추천해준 책, 그래 그래 효율성..

  

링크 : http://book.naver.com/bookdb/book_detail.nhn?bid=7405945

저자 마틴 레디 (DR. MARTIN REDDY)는 소프트웨어 컨설팅 회사인 CODE REDDY INC.의 설립자이자 CEO다.

  

  

![](/assets/images/posts/437/2638BF4F56777D61139560.JPEG)

  

  

  

chpater 1 소개

1.1애플리케이션 프로그래밍 인터페이스

1.1.1계약과 계약자

1.1.2C++로 구현하는 API

1.2API 설계의 차별화되는 특징

1.3API를 사용하는 이유

1.3.1좀 더 견고한 코드

1.3.2코드 재사용

1.3.3병렬 개발

1.4API를 사용하지 말아야 할 때

1.5예제 API

1.5.1API 계층

1.5.2실세계 예제

1.6파일 포맷과 네트워크 프로토콜

1.7이 책의 구성

  

chpater 2품질

2.1문제 도메인 모델

2.1.1훌륭한 추상화 제공

2.1.2핵심 객체 모델링

2.2구체적인 구현 숨기기

2.2.1물리적 은닉: 선언 vs 정의

2.2.2논리적 은닉: 캡슐화

2.2.3멤버 변수 감추기

2.2.4메서드 구현 숨기기

2.2.5클래스 구현 숨기기

2.3작게 완성하기

2.3.1지나친 약속은 금지

2.3.2가상 함수의 추가는 신중하게

2.3.3편리한 API

2.4쉬운 사용성

2.4.1한눈에 들어오는

2.4.2잘못 사용하기에도 어렵게

2.4.3일관성 있는

2.4.4수직적인

2.4.5견고한 자원 할당

2.4.6플랫폼 독립성

2.5느슨한 연결

2.5.1이름만을 사용한 연결

2.5.2클래스 연결 줄이기

2.5.3의도적인 중복

2.5.4매니저 클래스

2.5.5콜백과 옵저버, 알림

2.6안정화와 문서화, 테스트

  

  

chpater 3 패턴

3.1Pimpl 관용법

3.1.1Pimpl 사용

3.1.2의미론적 복사

3.1.3Pimpl과 스마트 포인터

3.1.4Pimpl의 장점

3.1.5Pimpl의 단점

3.1.6C의 Opaque 포인터

3.2싱글톤

3.2.1C++의 싱글톤 구현

3.2.2스레드에 안전한 싱글톤 만들기

3.2.3싱글톤 vs 의존성 삽입

3.2.4싱글톤 vs 모노스테이트

3.2.5싱글톤 vs 세션 상태

3.3팩토리 메서드

3.3.1추상 기본 클래스

3.3.2단순한 팩토리 예제

3.3.3확장 가능한 팩토리 예제

3\. 4API 래핑 패턴

3.4.1프록시 패턴

3.4.2어댑터 패턴

3.4.3퍼사드 패턴

3.5옵저버 패턴

3.5.1모델-뷰-컨트롤러

3.5.2옵저버 패턴 구현

3.5.3푸시 옵저버 VS 풀 옵저버

  

  

chpater 4 설계

4.1좋은 설계를 위한 사례

4.1.1기술적 부채의 증가

4.1.2부채 상환

4.1.3멀리 보는 설계

4.2기능적 요구사항 수집

4.2.1기능적 요구사항

4.2.2기능적 요구사항의 예

4.2.3요구사항 유지보수

4.3유즈 케이스 생성

4.3.1유즈 케이스 개발

4.3.2유즈 케이스 템플릿 사용

4.3.3좋은 유즈 케이스 작성

4.3.4요구사항과 애자일 개발

4.4API 설계 요소

4.5아키텍처 설계

4.5.1아키텍처 수립

4.5.2아키텍처의 제약사항

4.5.3주요 추상화 객체 식별

4.5.4핵심 객체 생성

4.5.5아키텍처 관점 패턴

4.5.6아키텍처 논의

4.6클래스 설계

4.6.1객체 지향 개념

4.6.2클래스 설계의 선택사항

4.6.3상속 사용

4.6.4리스코브 대리 원칙

4.6.5개방/폐쇄 원칙

4.6.6데메테르의 법

4.6.7클래스 이름

4.7함수 설계

4.7.1함수 설계의 선택사항

4.7.2함수 이름

4.7.3함수 파라미터

4.7.4예외 처리

  

  

chpater 5 API 개발 방법

5.1일반 C API

5.1.1ANSI C 기능

5.1.2ANSI C API의 장점

5.1.3ANSI C로 API 작성

5.1.4C++ 코드에서 C 함수 호출

5.1.5사례 연구: FMOD C API

5.2객체 지향 C++ API

5.2.1객체 지향 API의 장점

5.2.2객체 지향 API의 단점

5.2.3사례 연구: FMOD C++ API

5.3템플릿 기반 API

5.3.1템플릿 기반 API 예제245

5.3.2템플릿 vs 매크로

5.3.3템플릿 기반 API의 장점

5.3.4템플릿 기반 API의 단점

5.4데이터 주도 API

5.4.1데이터 주도 웹 서비스

5.4.2데이터 주도 API의 장점

5.4.3데이터 주도 API의 단점

5.4.4가변형 파라미터 리스트 지원

5.4.5사례 연구: FMOD 데이터 주도 API

  

  

chpater 6C++의 올바른 사용법

6.1네임스페이스

6.2생성자와 할당

6.2.1컴파일러 생성 함수 제어

6.2.2생성자와 할당 정의

6.2.3Explicit 키워드

6.3상수 정확성

6.3.1메서드 상수 정확성

6.3.2파라미터 상수 정확성

6.3.3리턴 값 상수 정확성

6.4템플릿

6.4.1템플릿 용어

6.4.2암시적 인스턴스화 API 설계

6.4.3명시적 인스턴스화 API 설계

6.5연산자 오버로딩

6.5.1오버로드 가능한 연산자

6.5.2자유 연산자와 멤버 연산자

6.5.3클래스에 새 연산자 추가

6.5.4연산자 문법

6.5.5형 변환 연산자

6.6함수 파라미터

6.6.1포인터 피라미터 vs 참조 파라미터

6.6.2기본 파라미터

6.7상수에 #DEFINE 사용 금지

6.8프렌드 사용 금지

6.9심벌 노출

6.10코딩 규칙

  

  

chpater 7 성능

7.1상수 참조로 입력 파라미터 전달

7.2#INCLUDE 의존성 최소화

7.2.1 “한곳에 몰아두는” 헤더 금지

7.2.2전방 선언

7.2.3#include 중복 방지

7.3상수 선언

7.3.1새로운 constexpr 키워드3

7.4초기화 리스트

7.5메모리 최적화

7.6필요시까지 인라인 사용 금지

7.7카피-온-라이트

7.8요소 반복

7.8.1반복자

7.8.2임의 접근

7.8.3배열 참조

7.9성능 분석

7.9.1시간 기반 분석

7.9.2메모리 기반 분석

7.9.3멀티스레드 분석

  

  

chpater 8버전 관리

8.1버전 번호

8.1.1버전 번호의 의미

8.1.2일부만 아는 버전 규칙

8.1.3버전 API 생성

8.2소프트웨어 브랜치 전략

8.2.1브랜치 전략

8.2.2브랜치 정책

8.2.3API와 병렬 브랜치

8.2.4파일 포맷과 병렬 제품

8.3API의 수명 주기

8.4호환성 수준

8.4.1하위 호환성

8.4.2기능적 호환성

8.4.3소스 호환성

8.4.4이진 호환성

8.4.5상위 호환성

8.5하위 호환성 유지

8.5.1기능 추가

8.5.2기능 변경

8.5.3기능 교체

8.5.4기능 제거

8.6API 리뷰

8.6.1API 리뷰의 목적

8.6.2사전 릴리즈 리뷰

8.6.3사전 커밋 API 리뷰

  

  

chpater 9 문서화

9.1문서화의 이유

9.1.1행동 정의

9.1.2인터페이스 계약 문서화

9.1.3행동 변화에 대한 의사소통

9.1.4문서화의 대상

9.2문서화의 유형

9.2.1자동화된 API 문서화

9.2.2개요 문서화

9.2.3예제와 튜토리얼

9.2.4릴리즈 노트

9.2.5라이선스 정보

9.3문서 활용

9.4DOXYGEN 사용

9.4.1구성 파일

9.4.2주석 스타일과 명령

9.4.3API 주석

9.4.4파일 주석

9.4.5클래스 주석

9.4.6메서드 주석

9.4.7열거형 주석

9.4.8예제 헤더 문서화

  

chpater 10 테스트

10.1테스트 코드가 필요한 이유

10.2API 테스트의 유형

10.2.1단위 테스트

10.2.2통합 테스트

10.2.3성능 테스트

10.3좋은 테스트 코드 작성

10.3.1좋은 테스트 코드의 특성

10.3.2테스트의 대상

10.3.3테스트의 선택과 집중

10.3.4QA 팀의 협업

10.4테스트 가능한 코드의 작성

10.4.1테스트 주도 개발

10.4.2스텁(Stub)과 목(Mock) 객체

10.4.3Private 코드 테스트

10.4.4테스트 결과 표명

10.4.5계약 프로그래밍

10.4.6기록과 재생 기능

10.4.7국제화 지원

10.5테스트 자동화 도구

10.5.1테스트 하네스

10.5.2코드 커버리지

10.5.3버그 추적

10.5.4지속적인 빌드 시스템

  

chpater 11 스크립팅

11.1스크립트 바인딩 추가

11.1.1확장 vs 임베딩

11.1.2스크립팅의 장점

11.1.3언어 호환성 문제

11.1.4언어 장벽 교차

11.2스크립트 바인딩 기법

11.2.1Boost Python

11.2.2SWIG

11.2.3Python-SIP

11.2.4COM 자동화

11.2.5CORBA

11.3BOOST PYTHON을 사용한 PYTHON 바인딩 추가

11.3.1Boost Python 바인딩

11.3.2Boost Python을 사용한 C++ API 래핑

11.3.3생성자

11.3.4Python API 확장

11.3.5C++의 상속

11.3.6교차 언어 다형성

11.3.7반복자 지원

11.3.8종합

11.4SWIG를 이용한 RUBY 바인딩 추가

11.4.1SWIG를 사용한 C++ API 래핑

11.4.2Ruby API 개선

11.4.3생성자

11.4.4Ruby API 확장

11.4.5C++의 상속

11.4.6교차 언어 다형성

11.4.7종합

  

  

chpater 12확장성

12.1플러그인을 통한 확장

12.1.1플러그인 모델의 개요

12.1.2플러그인 시스템 설계 이슈

12.1.3C++로 플러그인 개발

12.1.4플러그인 API

12.1.5예제 플러그인

12.1.6플러그인 매니저

12.1.7플러그인 버전 관리

12.2상속을 통한 확장

12.2.1기능 추가

12.2.2기능 수정

12.2.3상속과 STL

12.2.4상속과 열거형

12.2.5비지터 패턴

12.2.6서브 클래스 사용 금지

12.3템플릿을 통한 확장

12.3.1정책 기반 템플릿

12.3.2정교하게 반복되는 템플릿 패턴

