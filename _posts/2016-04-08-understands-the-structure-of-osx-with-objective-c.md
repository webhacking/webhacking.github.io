---
layout: post
title: "OSX 구조를 이해하면서 배우는 Objective C"
description: ""
categories : etc
sub_categories : ""
date: 2016-04-08
tags: []
comments: true
share: true
---

![](/assets/images/posts/579/2746A24E57074CAA31F8C9.JPEG)

  

  

  

저자 오기하라 타케시(荻原 剛志)는 오사카 대학 대학원 기초공학연구과 수료. 공학 박사. 오사카 대학 정보 처리 교육 센터에서 NEXT
컴퓨터로 교육용 계산기 시스템 도입에 종사했다. 그 후, 나라 첨단과학 기술대, 코베 대학, 코치 공과대학, 오사카 대학을 거쳐
2008년부터 쿄토 산업대학 컴퓨터 이공학부 교수. 소프트웨어 개발 방법에 관련 연구 및 심층 암호화를 연구했다. TOYVIEWER,
TYPIST 등 국제적으로 호평받는 MAC OS X용 소프트웨어 개발자이기도 하다. 신슈 출신

  

**CHAPTER 1 객체 기반 소프트웨어 작성**

1.1 객체 개념

1.2 모듈과 객체

1.2.1 소프트웨어 모듈

1.2.2 독립성 높은 모듈

1.2.3 모듈 정보 은폐

1.2.4 클래스 정의와 인터페이스

1.2.5 메시지 송신 구현

  

**CHAPTER 2 OBJECTIVE-C 프로그램**

2.1 객체와 메시지

2.1.1 메시지 표현식

2.1.2 메시지 셀렉터

2.1.3 인스턴스 생성과 초기화

2.2 클래스 정의

2.2.1 클래스 인터페이스

2.2.2 클래스 구현 부분

2.2.3 클래스 정의 예제

2.3 컴파일

2.3.1 간단한 컴파일 방법

2.3.2 분할 컴파일

2.4 프로그램 작성법

2.4.1 하이브리드 언어

2.4.2 C 함수 이용 방법

2.4.3 정적 변수 정의

2.4.4 헤더 파일 임포트

  

**CHAPTER 3 상속과 클래스**

3.1 상속 개념

3.1.1 슈퍼 클래스와 서브 클래스

3.1.2 클래스 계층

3.2 상속을 사용한 클래스 정의

3.2.1 상속 관계 선언

3.2.2 클래스 정의와 헤더 파일

3.2.3 상속과 메서드 호출

3.2.4 슈퍼 클래스의 메서드 호출

3.2.5 초기자 정의

3.3 상속을 사용한 프로그램 예제

3.3.1 메서드 추가 예제

3.3.2 메서드 재정의 예제

3.4 상속과 메서드 호출

3.4.1 SELF를 사용한 메서드 호출

3.4.2 SUPER를 사용한 메서드 호출

3.4.3 실험 프로그램

3.5 메서드 정의 시 주의사항

3.5.1 지역적인 메서드

3.5.2 지정 초기자

  

**CHAPTER 4 객체 형식과 동적 결합**

4.1 동적 결합

4.1.1 동적 결합이란

4.1.2 다형성

4.2 형식과 클래스

4.2.1 클래스명을 형식으로 사용

4.2.2 빈 포인터 NIL

4.2.3 형식의 정적 확인

4.2.4 정적 형식 확인 정리

4.3 프로그래밍과 형식 선언

4.3.1 서명이 다를 때

4.3.2 클래스 전방 선언

4.3.3 캐스트를 사용한 예제

4.4 인스턴스 변수의 정보 은폐

4.4.1 인스턴스 변수에 접근

4.4.2 접근자

4.4.3 인스턴스 변수의 가시성

4.4.4 구현 부분의 인스턴스 변수 정의

4.5 클래스 객체

4.5.1 클래스 객체란

4.5.2 클래스 객체 형식

4.5.3 클래스 메서드 정의

4.5.4 클래스 변수

4.5.5 클래스 객체 초기화

4.5.6 초기자 반환형

  

**CHAPTER 5 참조 카운터를 사용한 메모리 관리 방법**

5.1 동적 메모리 관리

5.1.1 메모리 관리의 필요성

5.1.2 카운터 관리 방식과 ARC, 가비지 컬렉션

5.2 수동 카운터 관리 방식

5.2.1 참조 카운터

5.2.2 참조 카운터 확인 프로그램

5.2.3 인스턴스를 해제하는 메서드 정의

5.2.4 접근자 메서드와 소유권

5.2.5 인스턴스 자동 해제

5.2.6 자동 해제 풀 사용법과 주의점

5.2.7 임시 인스턴스 생성

5.2.8 실행 반복과 자동 해제 풀

5.2.9 해제되지 않는 객체

5.3 분수 계산기 예제

5.3.1 분수 클래스 FRACTION

5.3.2 계산 결과를 저장하는 클래스 FRACREGISTER

5.3.3 메인 함수와 실행 예

5.4 ARC 개요

5.4.1 ARC란

5.4.2 수동 카운터 조작 금지

5.4.3 자동 해제 풀의 새로운 구문

5.4.4 변수 초깃값

5.4.5 메서드 패밀리

5.4.6 메서드 DEALLOC 정의

5.4.7 ARC를 사용한 프로그램 컴파일

5.4.8 ARC 기본 사항 정리

5.4.9 분수 계산 프로그램을 ARC로 동작시키기

5.5 유지 순환과 약한 참조

5.5.1 유지 순환

5.5.2 소유권과 객체의 관계

5.5.3 약한 참조

5.5.4 변수 제로화

5.5.5 객체 구조의 기본 방침

5.6 ARC 프로그래밍의 기타 주의사항

5.6.1 객체를 일반 포인터처럼 취급

5.6.2 객체를 저장하는 세터 메서드

5.6.3 메서드 인수를 통해 객체 받기

5.6.4 객체를 포함한 C 배열

5.6.5 구조체 관련 제약

5.6.6 컴파일러 지정

  

**CHAPTER 6 가비지 컬렉션 [복습]**

6.1 가비지 컬렉션 개요

6.1.1 필요 없는 객체를 찾으려면

6.1.2 프로그램 작성 시 주의사항

6.1.3 가비지 컬렉터 동작

6.1.4 FINALIZE 메서드 정의

6.1.5 컴파일 관련 설정

6.1.6 카운터 관리 방식의 메서드 취급

6.1.7 가비지 컬렉션을 사용한 프로그램 정리

6.2 가비지 컬렉션의 자세한 기능

6.2.1 세대별 가비지 컬렉션

6.2.2 약한 참조

6.2.3 제로화

6.2.4 가비지 컬렉션으로 회수되는 메모리 영역

6.2.5 수식자 __STRONG 사용 방법

6.2.6 NSGARBAGECOLLECTOR 클래스

6.2.7 런타임 API

6.3 메모리 관리 방식 비교

6.3.1 카운터 관리 방식과 가비지 컬렉션

6.3.2 메모리 관리를 다른 방법으로 변경

6.3.3 각종 메모리 관리

CHAPTER 7 선언 프로퍼티

7.1 프로퍼티란

7.1.1 프로퍼티를 사용한 프로그래밍

7.1.2 프로퍼티 개념

7.2 프로퍼티 선언과 기능

7.2.1 명시적인 프로퍼티 선언

7.2.2 프로퍼티 구현

7.2.3 @SYNTHESIZE와 인스턴스 변수

7.2.4 @SYNTHESIZE로 인스턴스 변수 생성

7.2.5 프로퍼티 속성 지정

7.2.6 값 설정 방법 지정

7.2.7 ATOMIC 관련 메모리 관리 속성

7.2.8 선언 프로퍼티와 상속

7.2.9 메서드 패밀리와 프로퍼티의 관계

7.3 도트 연산자를 사용한 프로퍼티 접근

7.3.1 도트 연산자 사용 방법

7.3.2 도트 연산자를 사용한 식 작성

7.3.3 도트 연산자는 언제 사용하는가

  

**CHAPTER 8 NSOBJECT 클래스와 런타임 시스템**

8.1 NSOBJECT 클래스

8.1.1 루트 클래스의 역할

8.1.2 클래스와 인스턴스

8.1.3 인스턴스 생성과 해제

8.1.4 초기화

8.1.5 객체 비교

8.1.6 객체 내용 설명

8.2 메시지 송신 구조

8.2.1 셀렉터와 SEL형

8.2.2 메시지 탐색

8.2.3 메시지 함수 구현

8.2.4 SELF에 대입

8.2.5 메시지 송신 실행 속도

8.2.6 클래스 객체와 루트 클래스

8.2.7 타깃-액션 패러다임

8.2.8 XCODE에서 액션 메서드와 아울렛 작성

8.3 OBJECTIVE-C와 COCOA 환경

8.3.1 COCOA 환경과 MAC OS X

8.3.2 COCOA TOUCH와 IOS

8.3.3 프레임워크

8.3.4 프레임워크 구성과 헤더 파일

8.4 새로운 런타임 시스템

8.4.1 64비트 모델 대응과 모던 런타임

8.4.2 데이터 모델이란

8.4.3 64비트 모델과 정수형

8.4.4 CORE GRAPHICS 부동소수점형

8.4.5 취약하지 않은 인스턴스 변수

  

**CHAPTER 9 FOUNDATION 프레임워크의 중요 클래스**

9.1 객체 변경 가능성

9.1.1 변경 가능 객체와 불가능 객체

9.1.2 변경 가능 객체 작성

9.2 문자열 클래스

9.2.1 객체 상수 문자열

9.2.2 NSSTRING

9.2.3 NSMUTABLESTRING

9.3 데이터 클래스

9.3.1 NSDATA

9.3.2 NSMUTABLEDATA

9.4 배열 클래스

9.4.1 NSARRAY

9.4.2 NSMUTABLEARRAY

9.4.3 배열 객체와 소유권

9.4.4 고속 열거

9.4.5 열거자 NSENUMERATOR

9.4.6 고속 열거와 열거자

9.4.7 집합 클래스

9.5 사전 클래스

9.5.1 사전 객체 개요

9.5.2 NSDICTIONARY

9.5.3 NSMUTABLEDICTIONARY

9.6 숫자값에 대응하는 랩퍼 클래스

9.6.1 NSNUMBER

9.6.2 NSVALUE

9.6.3 형식 코드와 @ENCODE()

9.6.4 NSNULL

9.7 NSURL

9.7.1 여기서 다루는 URL이란

9.7.2 NSURL 개요

9.7.3 NSURL을 사용한 리소스에 접근

  

**CHAPTER 10 카테고리**

10.1 카테고리 선언과 정의

10.1.1 카테고리란

10.1.2 카테고리와 파일 작성

10.1.3 서브 모듈로서의 카테고리

10.1.4 메서드 전방 선언

10.1.5 비공개 메서드

10.1.6 클래스 확장

10.1.7 카테고리와 선언 프로퍼티

10.2 기존 클래스에 카테고리 추가

10.2.1 새로운 메서드 추가

10.2.2 메서드 추가 예제

10.2.3 기존 메서드 덮어쓰기

10.3 연상 참조

10.3.1 연상 참조 개요

10.3.2 객체 연결과 참조

10.3.3 객체 저장 방법

10.3.4 연결 끊기

10.3.5 카테고리를 사용한 예제

  

**CHAPTER 11 추상 클래스와 클래스 클러스터**

11.1 추상 클래스

11.1.1 추상 클래스란

11.1.2 추상 클래스 예제

11.2 클래스 클러스터

11.2.1 클래스 클러스터 개념

11.2.2 실험 프로그램

11.2.3 프로그래밍 시 주의사항

11.3 클래스 클러스터의 서브 클래스 만들기

11.3.1 카테고리 대응

11.3.2 원시 메서드 재정의

11.3.3 문자열의 서브 클래스 만들기

  

**CHAPTER 12 프로토콜**

12.1 프로토콜 개념

12.1.1 프로토콜이란

12.1.2 객체 프로토콜

12.2 OBJECTIVE-C 프로토콜 선언

12.2.1 프로토콜 선언

12.2.2 프로토콜 채용

12.2.3 프로토콜 상속

12.2.4 프로토콜 지정 형식 선언

12.2.5 프로토콜 전방 선언

12.2.6 프로토콜 적합성 확인

12.2.7 필수 기능과 옵션 기능 지정

12.2.8 프로토콜을 사용한 프로그램 예제

12.3 비형식 프로토콜

12.3.1 비형식 프로토콜이란

12.3.2 비형식 프로토콜의 용도

  

**CHAPTER 13 객체 복사와 저장**

13.1 객체 복사

13.1.1 얕은 복사와 깊은 복사

13.1.2 존이란

13.1.3 복사 메서드 정의

13.1.4 COPY 메서드 예제

13.1.5 변경 가능한 복사의 작성

13.2 아카이브

13.2.1 객체 아카이브화

13.2.2 FOUNDATION 프레임워크의 아카이브 기능

13.2.3 아카이브화 메서드 정의

13.2.4 언아카이브 메서드 정의

13.2.5 아카이브와 언아카이버의 초기화 메서드

13.3 프로퍼티 리스트

13.3.1 프로퍼티 리스트 개요

13.3.2 아스키 코드 형식의 프로퍼티 리스트

13.3.3 XML 형식의 프로퍼티 리스트

13.3.4 프로퍼티 리스트의 변환과 확인

  

**CHAPTER 14 블록 객체**

14.1 블록 객체란

14.1.1 C 컴파일러와 GCD

14.1.2 블록 객체 정의

14.1.3 블록 객체와 형식 선언

14.1.4 블록 객체에 포함된 변수 동작

14.1.5 정렬 함수와 블록 객체

14.2 블록 객체 구조

14.2.1 블록 객체의 실체와 수명

14.2.2 피해야 할 작성 패턴

14.2.3 블록 객체의 복사

14.2.4 특별한 변수 지정 __BLOCK

14.3 OBJECTIVE-C와 블록 객체

14.3.1 메서드 정의와 블록 객체

14.3.2 OBJECTIVE-C 객체로서의 블록 객체

14.3.3 ARC와 블록 객체

14.3.4 블록 객체에 포함된 변수의 동작

14.3.5 컬렉션 클래스에 추가된 메서드

14.3.6 시트 표시에 블록 객체 사용 예

14.3.7 ARC로 블록 객체 사용 시 주의사항

  

**CHAPTER 15 메시지 송신 패턴**

15.1 애플리케이션과 실행 반복

15.1.1 실행 반복

15.1.2 타이머 객체

15.1.3 메시지의 지연 실행

15.2 델리게이트

15.2.1 델리게이트 개념

15.2.2 COCOA 환경의 델리게이트

15.2.3 델리게이트 설정과 프로토콜

15.2.4 델리게이트를 사용한 프로그래밍

15.3 알림

15.3.1 알림과 알림 센터 개념

15.3.2 알림 객체

15.3.3 알림 센터

15.3.4 알림 큐

15.4 리스폰더 체인

15.4.1 리스폰더 체인 개요

15.4.2 애플리케이션의 리스폰더 체인

15.5 메시지 전송

15.5.1 메시지 전송 구조

15.5.2 메시지 전송에 필요한 정보

15.5.3 메시지 전송 정의

15.5.4 메시지 사용 금지

15.5.5 프로그램 예제

15.6 되돌리기 구조

15.6.1 되돌리기 구조 개요

15.6.2 되돌리기 관리자에 기록하기

  

**CHAPTER 16 애플리케이션 구조**

16.1 애플리케이션 번들

16.1.1 애플리케이션 번들 구조

16.1.2 NIB 파일과 각종 언어 리소스

16.1.3 정보 파일의 주요 내용

16.1.4 NSBUNDLE과 리소스 접근

16.1.5 IOS와 리소스 접근

16.1.6 유니버설 바이너리

16.2 NIB 파일 로드

16.2.1 NIB 파일 인스턴스화

16.2.2 MAC OS X과 NIB 파일 로드

16.2.3 IOS와 NIB 파일 로드

16.2.4 NIB 파일 안의 유지 순환

16.2.5. NIB 파일 안의 객체 초기화

16.2.6 애플리케이션 실행

16.3. IOS 파일 저장 장소

16.3.1. 주요 디렉터리와 역할

16.3.2 디렉터리 경로 취득

16.4 사용자 기본값

16.4.1 설정값 저장

16.4.2 기본값 도메인

16.4.3 사용자 기본값을 조사하는 도구

16.4.4 NSUSERDEFAULTS 개요

16.5 애플리케이션의 지역화

16.5.1 메시지 지역화

16.5.2 지역화 지침

16.5.3 로케일

16.6 모듈의 동적 로드

16.6.1 로더블 번들

16.6.2 로더블 번들을 사용한 프로그래밍

16.6.3 플러그인 개요

  

**CHAPTER 17 예제: 간단한 이미지 뷰어**

17.1 APPLICATION 프레임워크와 인터페이스 빌더

17.2 프로그램 개요

17.2.1 객체 사이의 관계

17.2.2 알림

17.2.3 되돌리기와 되살리기

17.2.4 로더블 번들과 지역화

17.2.5 사용자 기본값

17.3 프로그램 해설

17.3.1 MAIN 함수와 클래스

17.3.2 클래스 WINCTRL

17.3.3 클래스 MYINSPECTOR

17.4 애플리케이션 번들 구축

17.4.1 컴파일과 설정 파일 작성

17.4.2 프로그램 동작 예

17.4.3 GUI 정의 파일과 프로그램

  

**CHAPTER 18 예외와 에러**

18.1 예외란

18.1.1 예외 처리 개념

18.1.2 OBJECTIVE-C 예외 처리

18.2 예외 처리 구조 개요

18.2.1 예외 핸들러와 예외 처리 도메인

18.2.2 예외를 나타내는 클래스 NSEXCEPTION

18.2.3 예외 처리 구조 구문

18.2.4 간단한 예외 처리 예제 프로그램

18.3 예외 발생과 전파

18.3.1 예외 전파

18.3.2 직접 예외 발생시키기

18.3.3 예외를 발생시키는 @THROW문

18.3.4 @CATCH의 특수 구문

18.3.5 예외 전파와 @FINALLY

18.3.6 예외 처리 프로그래밍 시 주의사항

18.4 어설션

18.4.1 어설션이란

18.4.2 어설션 매크로

18.5 에러 처리

18.5.1 에러 처리 구조의 목적

18.5.2 에러를 표시하는 클래스 NSERROR 사용 방법

18.5.3 에러 객체에서 정보 얻기

18.5.4 직접 에러 객체 만들기

18.6 에러 리스폰더 체인

18.6.1 에러 리스폰더 체인 구조

18.6.2 에러 객체의 변경과 복구

  

**CHAPTER 19 병렬 프로그래밍**

19.1 멀티스레드

19.1.1 스레드의 기본 개념

19.1.2 스레드 세이프

19.1.3 주의사항

19.1.4 NSTHREAD 사용해 스레드 생성

19.1.5 현재 스레드

19.1.6 GUI 애플리케이션과 스레드

19.2 상호 배제

19.2.1 상호 배제가 필요한 예

19.2.2 락

19.2.3 교착 상태

19.2.4 락 획득 시도

19.2.5 조건이 있는 락

19.2.6 NSRECURSIVELOCK

19.2.7 @SYNCHRONIZED

19.3 오퍼레이션 객체와 병렬 처리

19.3.1 새로운 병렬 처리 프로그래밍

19.3.2 NSOPERATION을 사용한 처리 개요

19.3.3 NSOPERATION과 NSOPERATIONQUEUE의 간단한 사용 방법

19.3.4 태스크가 모두 끝날 때까지 기다리기

19.3.5 오퍼레이션 객체를 사용한 간단한 예

19.3.6 NSINVOCATIONOPERATION 사용 방법

19.3.7 NSBLOCKOPERATION 사용 방법

19.3.8 NSBLOCKOPERATION에 여러 블록 객체 추가

19.3.9 태스크 사이에 의존 관계 설정

19.3.10 태스크에 우선순위 설정하기

19.3.11 병렬로 동작하는 태스크의 최대수 설정하기

19.3.12 태스크 중지하기

19.3.13 큐 스케줄링을 중단 상태로 만들기

19.4 병렬 처리의 예제 프로그램

19.4.1 프로그램 개요

19.4.2 클래스 BROWSINGVIEWERCTRL

19.4.3 클래스 BROWSINGWINCTRL

19.4.4 클래스 DRAWOPERATION

19.4.5 기타 변경

19.5 커넥션을 사용한 통신

19.5.1 커넥션

19.5.2 프록시

19.5.3 메서드의 포인터 인수

19.5.4 객체의 복사 전달

19.5.5 비동기 메시지

19.5.6 프로토콜 설정

19.5.7 실행 반복의 시작

19.5.8 메시지 송ㆍ수신 동작

19.5.9 스레드 사이의 커넥션

19.5.10 프로세스 사이의 커넥션

19.5.11 프로세스 사이의 커넥션 예제

  

**CHAPTER 20 키-값 코딩**

20.1 키-값 코딩 개요

20.1.1 키-값 코딩이란

20.1.2 키-값 코딩의 기본 동작

20.2 프로퍼티에 접근

20.2.1 키-값 코딩의 메서드 동작

20.2.2 속성값의 자동 변환

20.2.3 사전 객체와 키-값 코딩

20.2.4 키 패스를 사용한 접근

20.2.5 다대일 관계와 다대다 관계

20.2.6 배열 객체와 키-값 코딩

20.3 다대다 관계의 접근

20.3.1 인덱스가 있는 접근자 패턴

20.3.2 다대다 관계에 변경 가능한 접근

20.4 KVC 준수

20.4.1 프로퍼티 값 검증

20.4.2 키-값 코딩 준수

20.5 키-값 감시

20.5.1 키-값 감시의 기본

20.5.2 예제 프로그램

20.5.3 다대다 관계의 프로퍼티 감시

20.5.4 의존하는 키 등록

20.6 COCOA 바인딩 개요

20.6.1 타깃-액션 패러다임의 약점

20.6.2 COCOA 바인딩이란

20.6.3 COCOA 바인딩에 필요한 메서드

20.6.4 예제: 2차 함수 그래프를 그리는 소프트웨어

20.6.5 커스텀 뷰의 메서드 정의

  

**APPENDIX 부록**

A FOUNDATION 프레임워크 개요

B CORE FOUNDATION 프레임워크 개요

C 코딩 지침

칼럼 모아보기

칼럼 1: 미주알고주알 ‘객체지향’

칼럼 2: COCOA와 OBJECTIVE-C 역사

칼럼 3: C 언어의 새로운 규격

칼럼 4: 다양한 BOOL형

칼럼 5: 메서드 선언에서 형식을 지정하지 않았다면

칼럼 6: 레퍼런스와 SDK

칼럼 7: OBJECTIVE-C와 오픈 소스

칼럼 8: 관계 연산자 동작에 대해

칼럼 9: 중첩

칼럼 10: 정적 객체

칼럼 11: CONST 지정자

칼럼 12: 인트로스펙션

칼럼 13: 함수 포인터

칼럼 14: 조건 지정 컴파일

칼럼 15: 개수가 변하는 인수를 받는 메서드 정의

칼럼 16: 클래스 다중 상속

칼럼 17: 시스템 버전 차이에 대응하는 매크로

칼럼 18: 알림명과 예외명 정의

칼럼 19: 언어와 지역 지정

칼럼 20: 애플리케이션명 지역화하기

칼럼 21: 메시지 안의 어순

칼럼 22: 샌드박스

칼럼 23: OBJECTIVE-C용 디버거 기능

칼럼 24: 로그 출력 함수 NSLOG()

칼럼 25: 개수가 변하는 인수를 가진 매크로

칼럼 26: 단위 테스트

영어에 대해 한마디

